PUPPETS.LIFE WEB
----------------

Redirección ppts.co
Dinámica Kurt
App iOS
Responsive
Que avise si no estás en chrome (había pensando una huelga del puppet?)
Facebook Comments
Definir si quieres hacer un tamaño fijo de la app (revisa como se ve en esa situación con una pantalla mayor)
Sonido


---
Piensa la web como un pipeline de data:

	La data está en el giroscopio del telefono de ahi se transforma en un puppet => cómo es el pipeline?

		Theater.render( { dataProvider: P2PClient.connect( { url: P2PServer.connect().then() } ).then() } )
		

		Theater.render( {puppet: Puppet.render( { dataProvider: P2PClient.connect( { url: P2PServer.connect().then() } ).then() } ) } )



	Root
		Theater
		Comments
		Share


		Theater
			Puppet
			QP

			NSA
				.connect()
					.then()
						.play()
						.done()

https://stemkoski.github.io/Three.js/


/*
    var radius = 10
    var geometry = new THREE.SphereGeometry( radius, 16, 12 );
    geometry.applyMatrix( new THREE.Matrix4().makeScale( 1.0, 1.2, 1.5 ) );

    //var geometry = new THREE.CylinderGeometry( 2, 5, 20, 32 );
    var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
    var cylinder = new THREE.Mesh( geometry, material );

    cylinder.scale.set( 10,
                    5,
                    10 );
    utils.scene.add( cylinder );
    */
/*
    var material = new THREE.MeshBasicMaterial({
    color: 0x0000ff
});

var radius = 5;
var segments = 32;

//var circleGeometry = new THREE.CircleGeometry( radius, segments );
var circle = new THREE.Mesh( geometry, material );
circle.scale.set( 1,
                    50,
                    1 );
circle.position.set( 100,
                        100,
                        100 );
utils.scene.add( circle );
*/


/*
JOINT
var obj = {
    world: utils.world,
    type: 'jointDistance',
    body1: 'control-bar',
    body2: 'head',
    pos1: [20, 0, 0],
    pos2: [0, (head.size[1] / 2), 0],
    axe1: [1, 1, 1],
    axe2: [1, 1, 1],
    collision: true,
    min: baseDistance + 80,
    max: baseDistance + 120,
    spring: [10, 0.2],
    limit: [10, 0.2],
    motor: [10, 0.2],
    name: 'control-bar-head',
    color: '#FFAA58'
};
*/

if(type[0].substring(0,5) == 'joint'){ // is joint

    if(type[0] === 'joint')type[0] = 'jointHinge';

        var axe1 = obj.axe1 || [1,0,0];
        var axe2 = obj.axe2 || [1,0,0];
        var pos1 = obj.pos1 || [0,0,0];
        var pos2 = obj.pos2 || [0,0,0];

        pos1 = pos1.map(function(x){ return x * OIMO.INV_SCALE; });
        pos2 = pos2.map(function(x){ return x * OIMO.INV_SCALE; });

        var min, max;
        if(type[0]==="jointDistance"){
            min = obj.min || 0;
            max = obj.max || 10;
            min = min * OIMO.INV_SCALE;
            max = max * OIMO.INV_SCALE;
        }else{
            min = obj.min || 57.29578;
            max = obj.max || 0;
            min = min * OIMO.degtorad;
            max = max * OIMO.degtorad;
        }

        var limit = obj.limit || null;
        var spring = obj.spring || null;
        var motor = obj.motor || null;

        // joint setting
        var jc = new OIMO.JointConfig();
        jc.allowCollision = obj.collision || false;;
        jc.localAxis1.init(axe1[0], axe1[1], axe1[2]);
        jc.localAxis2.init(axe2[0], axe2[1], axe2[2]);
        jc.localAnchorPoint1.init(pos1[0], pos1[1], pos1[2]);
        jc.localAnchorPoint2.init(pos2[0], pos2[1], pos2[2]);
        if (typeof obj.body1 == 'string' || obj.body1 instanceof String) obj.body1 = this.getByName(obj.body1);
        if (typeof obj.body2 == 'string' || obj.body2 instanceof String) obj.body2 = this.getByName(obj.body2);
        jc.body1 = obj.body1;
        jc.body2 = obj.body2;

        var joint;
        switch(type[0]){
            case "jointDistance": joint = new OIMO.DistanceJoint(jc, min, max); 
                if(spring !== null) joint.limitMotor.setSpring(spring[0], spring[1]);
                if(motor !== null) joint.limitMotor.setSpring(motor[0], motor[1]);
            break;
            case "jointHinge": joint = new OIMO.HingeJoint(jc, min, max);
                if(spring !== null) joint.limitMotor.setSpring(spring[0], spring[1]);// soften the joint ex: 100, 0.2
                if(motor !== null) joint.limitMotor.setSpring(motor[0], motor[1]);
            break;
            case "jointPrisme": joint = new OIMO.PrismaticJoint(jc, min, max); break;
            case "jointSlide": joint = new OIMO.SliderJoint(jc, min, max); break;
            case "jointBall": joint = new OIMO.BallAndSocketJoint(jc); break;
            case "jointWheel": joint = new OIMO.WheelJoint(jc);  
                if(limit !== null) joint.rotationalLimitMotor1.setLimit(limit[0], limit[1]);
                if(spring !== null) joint.rotationalLimitMotor1.setSpring(spring[0], spring[1]);
                if(motor !== null) joint.rotationalLimitMotor1.setSpring(motor[0], motor[1]);
            break;
        }

        joint.name = obj.name || '';
        // finaly add to physics world
        this.addJoint(joint);
        return joint;

        OIMO.Link = function(Obj){
    var obj = Obj || {};
    if(!obj.world) return;

    if(obj.type === undefined) obj.type = "jointHinge";
    this.name = obj.name || '';

    // obsolete use world.add(obj)

    this.joint = obj.world.add(obj);

    // the world where i am
    /*this.parent = obj.world;

    this.name = obj.name || '';
    var type = obj.type || "jointHinge";
    var axe1 = obj.axe1 || [1,0,0];
    var axe2 = obj.axe2 || [1,0,0];
    var pos1 = obj.pos1 || [0,0,0];
    var pos2 = obj.pos2 || [0,0,0];

    pos1 = pos1.map(function(x){ return x * OIMO.INV_SCALE; });
    pos2 = pos2.map(function(x){ return x * OIMO.INV_SCALE; });

    var min, max;
    if(type==="jointDistance"){
        min = obj.min || 0;
        max = obj.max || 10;
        min = min*OIMO.INV_SCALE;
        max = max*OIMO.INV_SCALE;
    }else{
        min = obj.min || 57.29578;
        max = obj.max || 0;
        min = min*OIMO.TO_RAD;
        max = max*OIMO.TO_RAD;
    }

    var limit = obj.limit || null;
    var spring = obj.spring || null;
    var motor = obj.motor || null;

    // joint setting
    var jc = new OIMO.JointConfig();
    jc.allowCollision = obj.collision || false;;
    jc.localAxis1.init(axe1[0], axe1[1], axe1[2]);
    jc.localAxis2.init(axe2[0], axe2[1], axe2[2]);
    jc.localAnchorPoint1.init(pos1[0], pos1[1], pos1[2]);
    jc.localAnchorPoint2.init(pos2[0], pos2[1], pos2[2]);
    if (typeof obj.body1 == 'string' || obj.body1 instanceof String) obj.body1 = obj.world.getByName(obj.body1);
    if (typeof obj.body2 == 'string' || obj.body2 instanceof String) obj.body2 = obj.world.getByName(obj.body2);
    jc.body1 = obj.body1;
    jc.body2 = obj.body2;

    
    switch(type){
        case "jointDistance": this.joint = new OIMO.DistanceJoint(jc, min, max); 
            if(spring !== null) this.joint.limitMotor.setSpring(spring[0], spring[1]);
            if(motor !== null) this.joint.limitMotor.setSpring(motor[0], motor[1]);
        break;
        case "jointHinge": this.joint = new OIMO.HingeJoint(jc, min, max);
            if(spring !== null) this.joint.limitMotor.setSpring(spring[0], spring[1]);// soften the joint ex: 100, 0.2
            if(motor !== null) this.joint.limitMotor.setSpring(motor[0], motor[1]);
        break;
        case "jointPrisme": this.joint = new OIMO.PrismaticJoint(jc, min, max); break;
        case "jointSlide": this.joint = new OIMO.SliderJoint(jc, min, max); break;
        case "jointBall": this.joint = new OIMO.BallAndSocketJoint(jc); break;
        case "jointWheel": this.joint = new OIMO.WheelJoint(jc);  
            if(limit !== null) this.joint.rotationalLimitMotor1.setLimit(limit[0], limit[1]);
            if(spring !== null) this.joint.rotationalLimitMotor1.setSpring(spring[0], spring[1]);
            if(motor !== null) this.joint.rotationalLimitMotor1.setSpring(motor[0], motor[1]);
        break;
    }

    this.joint.name = this.name;
    
    // finaly add to physics world
    this.parent.addJoint(this.joint);*/
}